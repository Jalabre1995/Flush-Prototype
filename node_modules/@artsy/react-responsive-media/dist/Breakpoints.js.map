{"version":3,"sources":["../src/Breakpoints.ts"],"names":["breakpointKey","breakpoint","Array","isArray","join","Breakpoints","breakpoints","fromWidth","throughWidth","fromBreakpoint","findBreakpointAtWidth","undefined","throughBreakpoint","_sortedBreakpoints","slice","indexOf","width","find","i","nextBreakpoint","_breakpoints","values","max","length","valueBreakpoints","lastTuple","forEach","value","push","map","props","greaterThanOrEqual","at","between","Object","keys","sort","a","b","breakpointAndValue","betweenCombinations","reduce","acc","b1","b2","_mediaQueries","_createBreakpointQueries","lessThan","greaterThan","entries","type","queries","query","breakpointProps","onlyRenderAt","_normalizeProps","lowestAllowedWidth","Math","min","_findNextBreakpoint","highestAllowedWidth","toWidth","allowedWidths","fromIndex","to","Error","JSON","stringify","key","forBreakpoints","set","_createBreakpointQuery","Map","from","k","v"],"mappings":"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","sourcesContent":["import { MediaBreakpointProps } from \"./Media\"\nimport { createRuleSet, createClassName } from \"./Utils\"\n\n/**\n * A union of possible breakpoint props.\n */\nexport type MediaBreakpointKey = keyof MediaBreakpointProps\n\ntype ValueBreakpointPropsTuple<T, B> = [T, MediaBreakpointProps<B>]\n\ntype Tuple = [string, string]\n\nfunction breakpointKey(breakpoint: string | Tuple) {\n  return Array.isArray(breakpoint) ? breakpoint.join(\"-\") : breakpoint\n}\n\n/**\n * Encapsulates all breakpoint data needed by the Media component. The data is\n * generated on initialization so no further runtime work is necessary.\n */\nexport class Breakpoints<B extends string> {\n  static validKeys() {\n    return [\"at\", \"lessThan\", \"greaterThan\", \"greaterThanOrEqual\", \"between\"]\n  }\n\n  private _sortedBreakpoints: ReadonlyArray<string>\n  private _breakpoints: { [key: string]: number }\n  private _mediaQueries: {\n    at: Map<string, string>\n    lessThan: Map<string, string>\n    greaterThan: Map<string, string>\n    greaterThanOrEqual: Map<string, string>\n    between: Map<string, string>\n  }\n\n  constructor(breakpoints: { [key: string]: number }) {\n    this._breakpoints = breakpoints\n\n    this._sortedBreakpoints = Object.keys(breakpoints)\n      .map(breakpoint => [breakpoint, breakpoints[breakpoint]])\n      .sort((a, b) => (a[1] < b[1] ? -1 : 1))\n      .map(breakpointAndValue => breakpointAndValue[0] as string)\n\n    // List of all possible and valid `between` combinations\n    const betweenCombinations = this._sortedBreakpoints\n      .slice(0, -1)\n      .reduce(\n        (acc: Tuple[], b1, i) => [\n          ...acc,\n          ...this._sortedBreakpoints.slice(i + 1).map(b2 => [b1, b2] as Tuple),\n        ],\n        []\n      )\n\n    this._mediaQueries = {\n      at: this._createBreakpointQueries(\"at\", this._sortedBreakpoints),\n      lessThan: this._createBreakpointQueries(\n        \"lessThan\",\n        this._sortedBreakpoints.slice(1)\n      ),\n      greaterThan: this._createBreakpointQueries(\n        \"greaterThan\",\n        this._sortedBreakpoints.slice(0, -1)\n      ),\n      greaterThanOrEqual: this._createBreakpointQueries(\n        \"greaterThanOrEqual\",\n        this._sortedBreakpoints\n      ),\n      between: this._createBreakpointQueries(\"between\", betweenCombinations),\n    }\n  }\n\n  public get sortedBreakpoints() {\n    return this._sortedBreakpoints as B[]\n  }\n\n  public get dynamicResponsiveMediaQueries() {\n    return Array.from(this._mediaQueries.at.entries()).reduce(\n      (acc, [k, v]) => ({ ...acc, [k]: v }),\n      {}\n    )\n  }\n\n  public get largestBreakpoint() {\n    return this._sortedBreakpoints[this._sortedBreakpoints.length - 1]\n  }\n\n  public findBreakpointsForWidths = (\n    fromWidth: number,\n    throughWidth: number\n  ) => {\n    const fromBreakpoint = this.findBreakpointAtWidth(fromWidth)\n    if (!fromBreakpoint) {\n      return undefined\n    }\n    const throughBreakpoint = this.findBreakpointAtWidth(throughWidth)\n    if (!throughBreakpoint || fromBreakpoint === throughBreakpoint) {\n      return [fromBreakpoint] as B[]\n    } else {\n      return this._sortedBreakpoints.slice(\n        this._sortedBreakpoints.indexOf(fromBreakpoint),\n        this._sortedBreakpoints.indexOf(throughBreakpoint) + 1\n      ) as B[]\n    }\n  }\n\n  public findBreakpointAtWidth = (width: number) => {\n    return this._sortedBreakpoints.find((breakpoint, i) => {\n      const nextBreakpoint = this._sortedBreakpoints[i + 1]\n      if (nextBreakpoint) {\n        return (\n          width >= this._breakpoints[breakpoint] &&\n          width < this._breakpoints[nextBreakpoint]\n        )\n      } else {\n        return width >= this._breakpoints[breakpoint]\n      }\n    }) as B | undefined\n  }\n\n  public toRuleSets() {\n    return Object.entries(this._mediaQueries).reduce(\n      (acc: string[], [type, queries]) => {\n        queries.forEach((query, breakpoint) => {\n          // We need to invert the query, such that it matches when we want the\n          // element to be hidden.\n          acc.push(\n            createRuleSet(\n              createClassName(type, breakpoint),\n              `not all and ${query}`\n            )\n          )\n        })\n        return acc\n      },\n      []\n    )\n  }\n\n  public shouldRenderMediaQuery(\n    breakpointProps: MediaBreakpointProps,\n    onlyRenderAt: string[]\n  ): boolean {\n    breakpointProps = this._normalizeProps(breakpointProps)\n    if (breakpointProps.lessThan) {\n      const width = this._breakpoints[breakpointProps.lessThan]\n      const lowestAllowedWidth = Math.min(\n        ...onlyRenderAt.map(breakpoint => this._breakpoints[breakpoint])\n      )\n      return lowestAllowedWidth < width\n    } else if (breakpointProps.greaterThan) {\n      const width = this._breakpoints[\n        this._findNextBreakpoint(breakpointProps.greaterThan)\n      ]\n      const highestAllowedWidth = Math.max(\n        ...onlyRenderAt.map(breakpoint => this._breakpoints[breakpoint])\n      )\n      return highestAllowedWidth >= width\n    } else if (breakpointProps.greaterThanOrEqual) {\n      const width = this._breakpoints[breakpointProps.greaterThanOrEqual]\n      const highestAllowedWidth = Math.max(\n        ...onlyRenderAt.map(breakpoint => this._breakpoints[breakpoint])\n      )\n      return highestAllowedWidth >= width\n    } else if (breakpointProps.between) {\n      // TODO: This is the only useful breakpoint to negate, but we’ll\n      //       we’ll see when/if we need it. We could then also decide\n      //       to add `oustide`.\n      const fromWidth = this._breakpoints[breakpointProps.between[0]]\n      const toWidth = this._breakpoints[breakpointProps.between[1]]\n      const allowedWidths = onlyRenderAt.map(\n        breakpoint => this._breakpoints[breakpoint]\n      )\n      return !(\n        Math.max(...allowedWidths) < fromWidth ||\n        Math.min(...allowedWidths) >= toWidth\n      )\n    }\n    return false\n  }\n\n  public valuesWithBreakpointProps = <T>(\n    values: T[]\n  ): Array<ValueBreakpointPropsTuple<T, B>> => {\n    type ValueBreakpoints = [T, string[]]\n    const max = values.length\n    const valueBreakpoints: ValueBreakpoints[] = []\n    let lastTuple: ValueBreakpoints\n    this._sortedBreakpoints.forEach((breakpoint, i) => {\n      const value = values[i]\n      if (i < max && (!lastTuple || lastTuple[0] !== value)) {\n        lastTuple = [value, [breakpoint]]\n        valueBreakpoints.push(lastTuple)\n      } else {\n        lastTuple[1].push(breakpoint)\n      }\n    })\n\n    return valueBreakpoints.map(([value, breakpoints], i) => {\n      const props: MediaBreakpointProps<any> = {}\n      if (i === valueBreakpoints.length - 1) {\n        props.greaterThanOrEqual = breakpoints[0]\n      } else if (breakpoints.length === 1) {\n        props.at = breakpoints[0]\n      } else {\n        // TODO: This is less than ideal, would be good to have a `through`\n        //       prop, which unlike `between` is inclusive.\n        props.between = [breakpoints[0], valueBreakpoints[i + 1][1][0]]\n      }\n      return [value, props] as ValueBreakpointPropsTuple<T, B>\n    })\n  }\n\n  private _normalizeProps(\n    breakpointProps: MediaBreakpointProps\n  ): MediaBreakpointProps {\n    if (breakpointProps.at) {\n      const fromIndex = this._sortedBreakpoints.indexOf(breakpointProps.at)\n      const to = this._sortedBreakpoints[fromIndex + 1]\n      return to\n        ? { between: [breakpointProps.at, to] }\n        : { greaterThanOrEqual: breakpointProps.at }\n    }\n    return breakpointProps\n  }\n\n  private _createBreakpointQuery(\n    breakpointProps: MediaBreakpointProps\n  ): string {\n    breakpointProps = this._normalizeProps(breakpointProps)\n    if (breakpointProps.lessThan) {\n      const width = this._breakpoints[breakpointProps.lessThan]\n      return `(max-width:${width - 1}px)`\n    } else if (breakpointProps.greaterThan) {\n      const width = this._breakpoints[\n        this._findNextBreakpoint(breakpointProps.greaterThan)\n      ]\n      return `(min-width:${width}px)`\n    } else if (breakpointProps.greaterThanOrEqual) {\n      const width = this._breakpoints[breakpointProps.greaterThanOrEqual]\n      return `(min-width:${width}px)`\n    } else if (breakpointProps.between) {\n      // TODO: This is the only useful breakpoint to negate, but we’ll\n      //       we’ll see when/if we need it. We could then also decide\n      //       to add `outside`.\n      const fromWidth = this._breakpoints[breakpointProps.between[0]]\n      const toWidth = this._breakpoints[breakpointProps.between[1]]\n      return `(min-width:${fromWidth}px) and (max-width:${toWidth - 1}px)`\n    }\n    throw new Error(\n      `Unexpected breakpoint props: ${JSON.stringify(breakpointProps)}`\n    )\n  }\n\n  private _createBreakpointQueries(\n    key: MediaBreakpointKey,\n    forBreakpoints: ReadonlyArray<string | [string, string]>\n  ) {\n    return forBreakpoints.reduce<Map<string, string>>((map, breakpoint) => {\n      map.set(\n        breakpointKey(breakpoint),\n        this._createBreakpointQuery({\n          [key]: breakpoint,\n        })\n      )\n      return map\n    }, new Map())\n  }\n\n  private _findNextBreakpoint(breakpoint: string) {\n    const nextBreakpoint = this._sortedBreakpoints[\n      this._sortedBreakpoints.indexOf(breakpoint) + 1\n    ]\n    if (!nextBreakpoint) {\n      throw new Error(`There is no breakpoint larger than ${breakpoint}`)\n    }\n    return nextBreakpoint\n  }\n}\n"],"file":"Breakpoints.js"}